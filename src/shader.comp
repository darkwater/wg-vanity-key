#version 460

layout(local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) buffer InputData {
    uint n[];  // input secret key
} input_buf;

layout(set = 0, binding = 1) buffer OutputData {
    uint q[];  // output public key
} output_buf;

void add(out uint result[32], in uint a[32], in uint b[32]) {
    uint u = 0u;
    for (uint j = 0u; j < 31u; j++) {
        u += a[j] + b[j];
        result[j] = u & 255u;
        u >>= 8u;
    }
    u += a[31] + b[31];
    result[31] = u;
}

void sub(out uint result[32], in uint a[32], in uint b[32]) {
    uint u = 218;
    for (int j = 0; j < 31; j++) {
        u += a[j] + 65280 - b[j];
        result[j] = u & 255u;
        u >>= 8;
    }
    u += a[31] - b[31];
    result[31] = u;
}

void squeeze(inout uint a[32]) {
    uint u = 0u;
    for (uint j = 0u; j < 31u; j++) {
        u += a[j];
        a[j] = u & 255u;
        u >>= 8u;
    }
    u += a[31];
    a[31] = u & 127u;
    u = 19u * (u >> 7u);
    for (uint j = 0u; j < 31u; j++) {
        u += a[j];
        a[j] = u & 255u;
        u >>= 8u;
    }
    u += a[31];
    a[31] = u;
}

const uint MINUSP[32] = uint[](
    19u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
    0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
    0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
    0u, 0u, 0u, 0u, 0u, 0u, 0u, 128u
);

void freeze(inout uint a[32]) {
    uint aorig[32];
    for (uint j = 0u; j < 32u; j++) {
        aorig[j] = a[j];
    }
    add(a, aorig, MINUSP);
    uint negative = uint(-(int((a[31] >> 7) & 1)));
    for (uint j = 0u; j < 32u; j++) {
        a[j] ^= negative & (aorig[j] ^ a[j]);
    }
}

void mult(out uint result[32], uint a[32], uint b[32]) {
    for (uint i = 0u; i < 32u; i++) {
        uint u = 0u;
        for (uint j = 0u; j <= i; j++) {
            u += a[j] * b[i - j];
        }
        for (uint j = i + 1u; j < 32u; j++) {
            u += 38u * a[j] * b[i + 32u - j];
        }
        result[i] = u;
    }
    squeeze(result);
}

void mult121665(out uint result[32], in uint a[32]) {
    uint u = 0;
    for (int j = 0; j < 31; j++) {
        u += 121665 * a[j];
        result[j] = u & 255u;
        u >>= 8;
    }
    u += 121665 * a[31];
    result[31] = u & 127u;
    u = 19 * (u >> 7);
    for (int j = 0; j < 31; j++) {
        u += result[j];
        result[j] = u & 255u;
        u >>= 8;
    }
    u += result[31];
    result[31] = u;
}

void square(out uint result[32], in uint a[32]) {
    for (uint i = 0u; i < 32u; i++) {
        uint u = 0u;
        uint j = 0u;
        while (j < (i - j)) {
            u += a[j] * a[i - j];
            j += 1u;
        }
        j = i + 1u;
        while (j < (i + 32u - j)) {
            u += 38u * a[j] * a[i + 32u - j];
            j += 1u;
        }
        u *= 2u;
        if ((i & 1u) == 0u) {
            u += a[i / 2u] * a[i / 2u];
            u += 38u * a[i / 2u + 16u] * a[i / 2u + 16u];
        }
        result[i] = u;
    }
    squeeze(result);
}

void select(out uint p[2][32], out uint q[2][32], in uint r[2][32], in uint s[2][32], uint b) {
    uint bminus1 = b - 1u;
    for (int j = 0; j < 32; j++) {
        uint t = bminus1 & (r[0][j] ^ s[0][j]);
        p[0][j] = s[0][j] ^ t;
        q[0][j] = r[0][j] ^ t;

        t = bminus1 & (r[1][j] ^ s[1][j]);
        p[1][j] = s[1][j] ^ t;
        q[1][j] = r[1][j] ^ t;
    }
}

void recip(out uint result[32], in uint z[32]) {
    uint z2[32];
    uint z9[32];
    uint z11[32];
    uint z2_5_0[32];
    uint z2_10_0[32];
    uint z2_20_0[32];
    uint z2_50_0[32];
    uint z2_100_0[32];
    uint t0[32];
    uint t1[32];

    /* 2 */ square(z2, z);
    /* 4 */ square(t1, z2);
    /* 8 */ square(t0, t1);
    /* 9 */ mult(z9, t0, z);
    /* 11 */ mult(z11, z9, z2);
    /* 22 */ square(t0, z11);
    /* 2^5 - 2^0 = 31 */ mult(z2_5_0, t0, z9);

    /* 2^6 - 2^1 */ square(t0, z2_5_0);
    /* 2^7 - 2^2 */ square(t1, t0);
    /* 2^8 - 2^3 */ square(t0, t1);
    /* 2^9 - 2^4 */ square(t1, t0);
    /* 2^10 - 2^5 */ square(t0, t1);
    /* 2^10 - 2^0 */ mult(z2_10_0, t0, z2_5_0);

    /* 2^11 - 2^1 */ square(t0, z2_10_0);
    /* 2^12 - 2^2 */ square(t1, t0);

    /* 2^20 - 2^10 */ for (uint i = 1; i < 5u; i++) { square(t0, t1); square(t1, t0); }
    /* 2^20 - 2^0 */ mult(z2_20_0, t1, z2_10_0);

    /* 2^21 - 2^1 */ square(t0, z2_20_0);
    /* 2^22 - 2^2 */ square(t1, t0);
    /* 2^40 - 2^20 */ for (uint i = 1; i < 10u; i++) { square(t0, t1); square(t1, t0); }
    /* 2^40 - 2^0 */ mult(t0, t1, z2_20_0);

    /* 2^41 - 2^1 */ square(t1, t0);
    /* 2^42 - 2^2 */ square(t0, t1);
    /* 2^50 - 2^10 */ for (uint i = 1; i < 5u; i++) { square(t1, t0); square(t0, t1); }
    /* 2^50 - 2^0 */ mult(z2_50_0, t0, z2_10_0);

    /* 2^51 - 2^1 */ square(t0, z2_50_0);
    /* 2^52 - 2^2 */ square(t1, t0);
    /* 2^100 - 2^50 */ for (uint i = 1; i < 25u; i++) { square(t0, t1); square(t1, t0); }
    /* 2^100 - 2^0 */ mult(z2_100_0, t1, z2_50_0);

    /* 2^101 - 2^1 */ square(t1, z2_100_0);
    /* 2^102 - 2^2 */ square(t0, t1);
    /* 2^200 - 2^100 */ for (uint i = 1; i < 50u; i++) { square(t1, t0); square(t0, t1); }
    /* 2^200 - 2^0 */ mult(t1, t0, z2_100_0);

    /* 2^201 - 2^1 */ square(t0, t1);
    /* 2^202 - 2^2 */ square(t1, t0);
    /* 2^250 - 2^50 */ for (uint i = 1; i < 25u; i++) { square(t0, t1); square(t1, t0); }
    /* 2^250 - 2^0 */ mult(t0, t1, z2_50_0);

    /* 2^251 - 2^1 */ square(t1, t0);
    /* 2^252 - 2^2 */ square(t0, t1);
    /* 2^253 - 2^3 */ square(t1, t0);
    /* 2^254 - 2^4 */ square(t0, t1);
    /* 2^255 - 2^5 */ square(t1, t0);
    /* 2^255 - 21 */ mult(result, t1, z11);
}

void mainloop(inout uint work1[32], out uint work2[32], in uint e[32]) {
    uint xzm1[2][32];
    uint xzm[2][32];
    uint xzmb[2][32];
    uint xzm1b[2][32];
    uint xznb[2][32];
    uint xzn1b[2][32];
    uint a0[2][32];
    uint a1[2][32];
    uint b0[2][32];
    uint b1[2][32];
    uint c1[2][32];
    uint r[32];
    uint s[32];
    uint t[32];
    uint u[32];

    for (uint j = 0u; j < 32u; j++) {
        xzm1[0][j] = work1[j];
        xzm1[1][j] = 0u;
        xzm[0][j] = 0u;
        xzm[1][j] = 0u;
    }
    xzm1[1][0] = 1u;
    xzm[0][0] = 1u;

    // run all the way down to 0, then underflow and become larger than 254
    for (int pos = 254; pos >= 0; pos--) {
        uint b = (e[pos / 8u] >> (pos & 7u)) & 1u;
        select(xzmb, xzm1b, xzm, xzm1, b);
        add(a0[0], xzmb[0], xzmb[1]);
        sub(a0[1], xzmb[0], xzmb[1]);
        add(a1[0], xzm1b[0], xzm1b[1]);
        sub(a1[1], xzm1b[0], xzm1b[1]);
        square(b0[0], a0[0]);
        square(b0[1], a0[1]);
        mult(b1[0], a1[0], a0[1]);
        mult(b1[1], a1[1], a0[0]);
        add(c1[0], b1[0], b1[1]);
        sub(c1[1], b1[0], b1[1]);
        square(r, c1[1]);
        sub(s, b0[0], b0[1]);
        mult121665(t, s);
        add(u, t, b0[0]);
        mult(xznb[0], b0[0], b0[1]);
        mult(xznb[1], s, u);
        square(xzn1b[0], c1[0]);
        mult(xzn1b[1], r, work1);
        select(xzm, xzm1, xznb, xzn1b, b);
    }

    for (uint j = 0u; j < 32u; j++) {
        work1[j] = xzm[0][j];
        work2[j] = xzm[1][j];
    }
}

const uint BASE[32] = uint[](
    9u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
    0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
    0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,
    0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u
);

void main() {
    uint idx = gl_GlobalInvocationID.x;

    uint work1[32];
    uint work2[32];
    uint work3[32];
    uint e[32];
    for (uint i = 0u; i < 32u; i++) {
        e[i] = input_buf.n[i + idx * 32u];
    }
    e[0] &= 248u;
    e[31] &= 127u;
    e[31] |= 64u;
    for (uint i = 0u; i < 32u; i++) {
        work1[i] = BASE[i];
    }

    mainloop(work1, work2, e);

    uint t_work2[32];
    for (uint i = 0u; i < 32u; i++) {
        t_work2[i] = work2[i];
    }

    recip(work2, t_work2);
    mult(work3, work1, work2);
    freeze(work3);

    for (uint i = 0u; i < 32u; i++) {
        output_buf.q[i + idx * 32u] = work3[i];
    }
}
